import React, { useState, useEffect } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import axios from "../api/axiosConfig";
import FullScreenGraph from "./FullScreenGraph";
import RequirementDetailView from "./RequirementDetailView";
import { Loader2, AlertTriangle, ArrowLeft } from "lucide-react";
import FileHierarchy from './FileHierarchy';

export default function ResultViewer() {
    const [loadedRequirements, setLoadedRequirements] = useState(null);
    const [loadError, setLoadError] = useState("");
    const [selectedRequirement, setSelectedRequirement] = useState(null);
    const [graphResponses, setGraphResponses] = useState([]);
    const [loadingGraph, setLoadingGraph] = useState(false);
    const [graphError, setGraphError] = useState("");
    const [isFullScreen, setIsFullScreen] = useState(false);
    const [detailGraphIndex, setDetailGraphIndex] = useState(0);
    const location = useLocation();
    const navigate = useNavigate();
    const result = location.state?.result;

    // --- Effects ---
    useEffect(() => {
        if (!result) {
            setLoadError("No analysis results available. Please analyze a codebase first.");
            return;
        }

        setLoadError("");
        setLoadedRequirements(null);
        setSelectedRequirement(null);
        setGraphResponses([]);
        setGraphError("");
        setIsFullScreen(false);
        setDetailGraphIndex(0);

        const storedResult = localStorage.getItem("requirementsOutput");
        if (storedResult) {
            try {
                const parsedResult = JSON.parse(storedResult);
                if (parsedResult && Array.isArray(parsedResult.requirements)) {
                    setLoadedRequirements({ files: parsedResult.requirements });
                } else {
                    console.error("Stored data format invalid:", parsedResult);
                    setLoadError("Failed to load results: Invalid data format.");
                    localStorage.removeItem("requirementsOutput");
                }
            } catch (e) {
                console.error("Failed to parse stored results:", e);
                setLoadError("Failed to load results: Could not parse data.");
                localStorage.removeItem("requirementsOutput");
            }
        } else {
            setLoadError("No analysis results found in storage.");
        }
    }, [result]);

    useEffect(() => {
        const fetchGraphs = async () => {
            if (!selectedRequirement?.requirements?.trim()) {
                setGraphResponses([]);
                setGraphError(
                    selectedRequirement ? "No requirements text found for this file." : ""
                );
                setLoadingGraph(false);
                return;
            }

            setLoadingGraph(true);
            setGraphResponses([]);
            setGraphError("");
            try {
                const payload = { requirement: selectedRequirement.requirements };
                const response = await axios.post("/analysis/graphs", payload);
                const data = Array.isArray(response.data) ? response.data : [];
                const validGraphs = data.filter((g) => g && g.generated_code) || [];

                setGraphResponses(validGraphs);
                setDetailGraphIndex(0);

                if (validGraphs.length === 0) {
                    setGraphError("No valid graphs were generated by the analysis.");
                }
            } catch (error) {
                console.error("Error fetching graphs:", error);
                const errorMsg =
                    error.response?.data?.detail || error.message || "Server error";
                setGraphError(`Failed to fetch graphs: ${errorMsg}`);
            } finally {
                setLoadingGraph(false);
            }
        };

        if (selectedRequirement) {
            fetchGraphs();
        } else {
            setGraphResponses([]);
            setGraphError("");
            setLoadingGraph(false);
            setDetailGraphIndex(0);
        }
    }, [selectedRequirement]);

    // --- Event Handlers ---
    // const handleSelectRequirement = (requirement) => {
    //     setSelectedRequirement(requirement);
    // };

    const handleGoBack = () => {
        if (selectedRequirement) {
            setSelectedRequirement(null);
        } else {
            navigate('/');
        }
    };

    const handleGraphIndexChange = (newIndex) => {
        setDetailGraphIndex(newIndex);
    };

    const handleFullscreen = () => {
        setIsFullScreen(true);
    };

    const handleViewFile = (file) => {
        const requirement = result?.requirements.find(
            req => req.file_name === file.name || req.relative_path === file.path
        );
        if (requirement) {
            setSelectedRequirement(requirement);
        }
    };

    // --- Main Content Determination ---
    let content = null;
    if (loadError) {
        content = (
            <div className="flex items-center justify-center py-12 text-red-600">
                <AlertTriangle className="h-8 w-8 mr-3" />
                {loadError}
            </div>
        );
    } else if (!loadedRequirements) {
        content = (
            <div className="flex items-center justify-center py-12 text-teal-600">
                <Loader2 className="h-8 w-8 animate-spin mr-3" />
                Loading results...
            </div>
        );
    } else if (selectedRequirement) {
        content = (
            <RequirementDetailView
                requirement={selectedRequirement}
                graphResponses={graphResponses}
                isLoadingGraph={loadingGraph}
                graphError={graphError}
                selectedGraphIndex={detailGraphIndex}
                onGraphIndexChange={handleGraphIndexChange}
                onGoBack={handleGoBack}
                onFullscreen={handleFullscreen}
            />
        );
    } else {
        content = (
            <div className="flex flex-col items-center w-full min-h-screen p-8 bg-gradient-to-br from-teal-50 to-teal-100">
                <div className="flex items-center justify-between w-full max-w-5xl mb-6">
                    <h2 className="text-3xl font-bold text-teal-800 animate-fadeIn">
                        Project Structure
                    </h2>
                    <button
                        onClick={handleGoBack}
                        className="flex items-center px-4 py-2 bg-teal-100 hover:bg-teal-200 text-teal-800 rounded-lg transition-all duration-200 text-sm font-semibold shadow-lg hover:scale-105"
                        aria-label="Back to dashboard"
                    >
                        <ArrowLeft className="w-4 h-4 mr-1" />
                        Back to Dashboard
                    </button>
                </div>
                <div className="w-full max-w-5xl">
                    {result?.file_hierarchy ? (
                        <FileHierarchy 
                            fileHierarchy={result.file_hierarchy}
                            onViewFile={handleViewFile}
                        />
                    ) : (
                        <div className="text-teal-600 text-center py-12 text-lg">
                            No project structure available. Please analyze a valid codebase.
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // --- Fullscreen Logic ---
    const selectedGraphForFullscreen =
        graphResponses?.[detailGraphIndex]?.generated_code;
    const canShowFullscreen = isFullScreen && selectedGraphForFullscreen;

    // --- Final Render ---
    return (
        <div className="min-h-screen flex flex-col bg-gray-50">
            {content}
            {canShowFullscreen && (
                <FullScreenGraph
                    chart={selectedGraphForFullscreen}
                    onClose={() => setIsFullScreen(false)}
                    className="bg-teal-700 text-white shadow-lg"
                />
            )}
        </div>
    );
}